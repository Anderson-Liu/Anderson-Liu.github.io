<!DOCTYPE html>






  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文整理自GitChat居玉皓的达人课《Webpack 前端工程化入门》 曾经的 Web 开发的做法和缺陷： 在 HTML 中插入一个 script 标签，直接在里面书写代码；问题： 全局作用域的污染。由于在每个 script 标签下顶层作用域即全局作用域，直接进行变量和函数声明会造成全局命名空间污染。假如一个页面有多个 script 标签，它们之间很有可能发生命名冲突。 代码重用性差。在一个多页">
<meta name="keywords" content="Javascript,Webpack">
<meta property="og:type" content="article">
<meta property="og:title" content="为什么要使用Webpack">
<meta property="og:url" content="http://peacesky.cn/2018/05/08/Why use Webpack/index.html">
<meta property="og:site_name" content="Peacesky">
<meta property="og:description" content="本文整理自GitChat居玉皓的达人课《Webpack 前端工程化入门》 曾经的 Web 开发的做法和缺陷： 在 HTML 中插入一个 script 标签，直接在里面书写代码；问题： 全局作用域的污染。由于在每个 script 标签下顶层作用域即全局作用域，直接进行变量和函数声明会造成全局命名空间污染。假如一个页面有多个 script 标签，它们之间很有可能发生命名冲突。 代码重用性差。在一个多页">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-05-08T09:14:22.663Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="为什么要使用Webpack">
<meta name="twitter:description" content="本文整理自GitChat居玉皓的达人课《Webpack 前端工程化入门》 曾经的 Web 开发的做法和缺陷： 在 HTML 中插入一个 script 标签，直接在里面书写代码；问题： 全局作用域的污染。由于在每个 script 标签下顶层作用域即全局作用域，直接进行变量和函数声明会造成全局命名空间污染。假如一个页面有多个 script 标签，它们之间很有可能发生命名冲突。 代码重用性差。在一个多页">






  <link rel="canonical" href="http://peacesky.cn/2018/05/08/Why use Webpack/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>为什么要使用Webpack | Peacesky</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Peacesky</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Under the peace sky.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://peacesky.cn/2018/05/08/Why use Webpack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anderson">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peacesky">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">为什么要使用Webpack
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-08 10:23:37 / Modified: 17:14:22" itemprop="dateCreated datePublished" datetime="2018-05-08T10:23:37+08:00">2018-05-08</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>本文整理自GitChat居玉皓的达人课</code><a href="http://gitbook.cn/gitchat/column/59e065f64f7fbe555e479204#catalog" target="_blank" rel="noopener">《Webpack 前端工程化入门》</a><code></code></p>
<h2 id="曾经的-Web-开发的做法和缺陷："><a href="#曾经的-Web-开发的做法和缺陷：" class="headerlink" title="曾经的 Web 开发的做法和缺陷："></a>曾经的 Web 开发的做法和缺陷：</h2><ul>
<li>在 HTML 中插入一个 script 标签，直接在里面书写代码；问题：</li>
<li>全局作用域的污染。由于<strong>在每个 script 标签下顶层作用域即全局作用域，直接进行变量和函数声明会造成全局命名空间污染</strong>。假如一个页面有多个 script 标签，它们之间很有可能发生命名冲突。</li>
<li>代码重用性差。在一个多页面应用的场景下，经常会有一些逻辑是这些页面之间共有的，此时我们不得不将这些代码复制粘贴到各个页面中。而当此处逻辑改动的时候我们也需要去更新所有页面的代码，造成很多额外的成本。</li>
</ul>
<a id="more"></a>
<h2 id="后来的解决办法"><a href="#后来的解决办法" class="headerlink" title="后来的解决办法"></a>后来的解决办法</h2><p>后来逐渐有一些针对这些问题的解决办法：</p>
<ul>
<li>首先，可以将 HTML 中内联的 JavaScript 提取出来成为单独的 JavaScript 文件。比如说一些页面公有的逻辑可以放在类似 common.js 中来被各个页面引用，这可以解决各个页面之间重用的问题。</li>
<li>至于全局作用域污染的问题，则可以使用立即执行函数表达式将它包起来（ IIFE ），只把接口暴露到全局上。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过立即执行函数表达式将作用域隔离</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>看上去好像问题已经得到了解决，然而随着页面逻辑的复杂度增加开发者又面临了新的问题：</p>
<ul>
<li>页面 JavaScript 文件的引用顺序由于 HTML 页面引用和处理 JavaScript 文件只能是顺序的（不考虑 async 等），因此页面的 JavaScript 之间依赖关系也必须是顺序的。而我们知道一个大型工程内部的模块依赖关系通常是树状的（比如 index.js 依赖 a、b、c 三个模块，而 a、b、c 又有各自的依赖），简单的顺序依赖关系无法满足需求。例如在 jQuery 最流行的时期，jQuery 本身以及其相关的插件之间有着各种各样的依赖关系，有些库可能自身包含 jQuery，不同的插件可能需要不同的 jQuery 版本，这些问题都不是简单的顺序依赖关系可以解决的。</li>
<li>页面引用的 JavaScript 文件的长度与数量如何权衡随着页面逻辑的增加，工程中的 JavaScript 文件越来越长，也越来越难以维护。一个页面的单个 JavaScript 文件可能有数千行甚至上万行。而如果按照功能来把页面逻辑切割成一个个小的 JavaScript 文件，则最终会走到另一个极端——页面请求过多。我们知道每个 HTTP 请求都是需要连接时间的，对于小模块而言每一个都要单独建立连接总归得不偿失，必然会导致页面渲染速度的下降。</li>
</ul>
<h2 id="走向正轨的第一步——模块化"><a href="#走向正轨的第一步——模块化" class="headerlink" title="走向正轨的第一步——模块化"></a>走向正轨的第一步——模块化</h2><ul>
<li>模块标准<br>CommonJS 以及 AMD 的出现，为前端定义了模块的标准。</li>
<li><p>实现模块化标准的库也有了实现这些模块化的库，比如 RequireJS 以及 Browserify。可以让开发者将自己工程中的代码按模块进行划分，模块之间也不再仅仅是简单的顺序依赖关系。</p>
</li>
<li><p>对于开发者而言开发体验更加友好，因为开发中每次需要关注的仅仅是单个模块，而不是堆放在一起的上千行 JavaScript 文件；</p>
</li>
<li>而对于客户端来说则只用接受单一的打包产物，解决了文件数量过多导致 HTTP 请求耗时长的问题。</li>
</ul>
<h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ul>
<li>作用域封装，避免全局变量污染</li>
<li>提高代码复用性</li>
<li>解除耦合</li>
<li>按需加载</li>
</ul>
<h2 id="JavaScript-模块发展简史"><a href="#JavaScript-模块发展简史" class="headerlink" title="JavaScript 模块发展简史"></a>JavaScript 模块发展简史</h2><h4 id="最原始的方式-script-标签"><a href="#最原始的方式-script-标签" class="headerlink" title="最原始的方式: script 标签"></a>最原始的方式: script 标签</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//mycdn.com/moduleA.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"//mycdn.com/moduleB.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"//mycdn.com/main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>缺陷: 这种方法的缺陷是所有这些脚本都是<strong>共用全局的作用域</strong>。在任何一个 JavaScript 文件中进行顶层作用域的变量或函数声明，都会暴露在全局中，使得其它脚本也相应获取。当应用的规模和复杂度上升，<strong>这些脚本之间很容易发生命名冲突，从而导致不可预知的问题。</strong></p>
<h4 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式(IIFE)"></a>立即执行函数表达式(IIFE)</h4><p>IIFE 的实现原理是把代码包裹在一个函数中，并且在声明这个函数之后立即执行它，这样相当于为代码单独创建了一个作用域。比如在下面的代码中我们创建了一个立即执行函数表达式，变量的声明处于它自己的函数作用域内，与其它的模块作用域隔离开:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// foobar 并不会暴露在全局作用域</span></span><br><span class="line">  <span class="keyword">var</span> foobar = <span class="string">"Hello IIFE!"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foobar);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果通过这种方法封装的模块需要与别的模块发生交互，则可以将特定的对象绑定在全局来允许其它模块通过全局对象获取，比如下面的形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将 calculator 绑定在全局对象上，使其它模块调用</span></span><br><span class="line">  <span class="built_in">window</span>.calculator = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sub: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line">calculator.add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>立即执行函数表达式的缺点在于，如果模块之间有着依赖关系，必须将它们按照特定的顺序引入到页面中。比如上面的 calculator，必须使定义 calculator 的 <code>calculator.js</code> 先执行，再执行调用的模块。<strong>由于这种依赖关系是隐式的，当所有这些模块都互相依赖时，文件的引入顺序将变得难以维护。</strong></p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>AMD 是 Asynchronous Module Definition（异步模块定义）的缩写。下面的代码使用 AMD 规范定义了一个模块：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个求和的模块</span></span><br><span class="line">define(<span class="string">"getSum"</span>, [<span class="string">"math"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"sum: "</span> + math.sum(a, b));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 AMD 中定义模块是使用  <code>define</code>  函数，它可以接受三个参数。</p>
<ul>
<li>第一个参数是当前模块的 ID，相当于给这个模块起一个名字；</li>
<li>第二个参数是当前模块的依赖，比如上面我们定义的  <code>getSum</code>模块需要  <code>math</code>  模块的依赖;</li>
<li>第三个参数可以是函数或者对象。如果是函数，可以利用函数的返回值将定义的模块接口导出；如果是对象，则代表它为当前模块的导出值。</li>
</ul>
<p>通过这种形式定义模块的好处在于:</p>
<ul>
<li>它  <strong>显式</strong>  地表达出了每个模块所依赖的其它模块。</li>
<li>并且模块定义也不再绑定到全局对象上，不必担心其在别的地方被篡改。</li>
</ul>
<h4 id="Browserify-与-CommonJS"><a href="#Browserify-与-CommonJS" class="headerlink" title="Browserify 与 CommonJS"></a>Browserify 与 CommonJS</h4><p>Browserify 的出现带来了浏览器环境模块的变革。它是一个运行在 Node 环境下的模块打包工具，可以把模块按照 Node.js 的模块规则合并为浏览器支持的形式，这使得浏览器端的框架类库也可以按照 CommonJS 的形式编写。在 CommonJS 中每个文件是一个模块，并且拥有属于自己的作用域和上下文。<strong>模块的依赖通过&nbsp;</strong><code><strong>require</strong></code><strong>&nbsp;函数来引入。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">"./math"</span>);</span><br></pre></td></tr></table></figure>
<p>如果想把模块的接口暴露给外部，则要通过  <code>exports</code>  将其导出，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.getSum = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AMD 和 CommonJS 具有同样的特性——<strong>模块的依赖必须显式引入</strong>，这样就解决了之前维护复杂模块引入时的顺序问题。</p>
<h4 id="ES6-Module"><a href="#ES6-Module" class="headerlink" title="ES6 Module"></a>ES6 Module</h4><p>ES6 Module 是目前比较推荐开发者使用的模块标准。<strong>之所以在过去我们有各种不同的模块化标准是因为 JavaScript 这门语言本身不具备模块化的特性，而现在 ES6 中已经具备了。</strong>ES6 Module 的模块语法和 CommonJS 很像，它通过  <code>import</code>  和  <code>export</code>  来进行模块的导入和导出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="keyword">from</span> <span class="string">"./math"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ES6 Module 中也是每个文件作为一个模块。<strong>和 CommonJS 不同的是，ES6 Module 的模块的依赖是静态的，或者说是在编译时确定的，而不是运行时确定的。</strong></p>
<p>举个例子，我们可以在 CommonJS 中的  <code>if</code>  语句中 require 模块，根据代码运行时  <code>if</code>  的判断条件决定是否要引入该模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据运行时条件确定是否引入</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Date</span>.now() &gt; <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2019-01-01"</span>)) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"./my_module"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>而在 ES6 Module 中则不允许这样做，</strong><code><strong>import</strong></code><strong>&nbsp;必须在代码的顶层作用域</strong>，这意味着你不能把它放在  <code>if</code>  等代码块中。ES6 Module 这样规定的原因在于<strong>可以使编译器在编译阶段就可以获取到整个依赖树</strong>，从而进行代码静态分析层面的优化，比如检测出哪些模块是从来没有被使用过的，然后从打包结果中优化掉等等。</p>
<h4 id="动态加载模块"><a href="#动态加载模块" class="headerlink" title="动态加载模块"></a>动态加载模块</h4><ul>
<li>CommonJS 可以直接使用<code>require</code>实现:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"moduleA"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">"moduleB"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 ES6 Module 中,由于上面我们提到的 import 是在编译时被处理而非运行时,因此无法实现动态加载的特性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'moduleA'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">import</span> foobar <span class="keyword">from</span> (foo + bar);</span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，tc39 提出了一个  <code>import()</code>  函数提案。它可以接受一个参数，指定所加载的模块，并且返回一个 Promise 对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">"foo"</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">"bar"</span>;</span><br><span class="line"><span class="keyword">import</span>(foo + bar)</span><br><span class="line">  .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foobar loaded:"</span>, <span class="built_in">module</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="模块打包原理简述–Webpack"><a href="#模块打包原理简述–Webpack" class="headerlink" title="模块打包原理简述–Webpack"></a>模块打包原理简述–Webpack</h4><p>Webpack 以及其它的一些打包工具最基本的功能就是<strong>按照我们定义好的依赖树将模块合并成单一的文件</strong>，让浏览器能够<strong>按照预想的依赖顺序去执行</strong>。这个过程我们通常将它叫做模块打包。<br>Webpack 打包 ES6 Module  的例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-bundle &amp;&amp; <span class="built_in">cd</span> webpack-bundle</span><br><span class="line">touch app.js &amp;&amp; touch module.js &amp;&amp; touch webpack.config.js</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> moduleLog <span class="keyword">from</span> <span class="string">"./module.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"app.js loaded."</span>);</span><br><span class="line">moduleLog();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">"module.js loaded."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用简单的配置文件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./app.js"</span>,</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后使用 Webpack 进行打包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Webpack 版本需要大于等于 2，这里使用的版本是 4.5.0</span></span><br><span class="line">webpack</span><br></pre></td></tr></table></figure>
<p><code>app.js</code> 是我们的打包入口文件,<code>dist/bundle.js</code>是最终的打包合并结果文件。Webpack 会在打包的过程中从入口 app.js 开始查找所有依赖的模块，并最终包装和合并这些模块放在 bundle.js 中。接下来让我们分析一下打包结果 dist/bundle.js 的大体结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(<span class="number">0</span>); <span class="comment">// entry file</span></span><br><span class="line">&#125;)([</span><br><span class="line">  <span class="comment">/* modules array */</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>这段代码总体上来看是一个立即执行函数表达式，<strong>它只有一个参数 modules</strong>，即 Webpack 从入口文件开始检索到的所有依赖模块。每一个依赖模块会被 Webpack 进行一次包装，放到 modules array 的数组中等待代码运行时调用。上面立即执行的匿名函数体内分为几个部分。首先定义了一个 installedModules 对象用来放置已经加载过的模块。接着定义了  <code>__webpack_require__</code>，这个函数是 Webpack 模块加载的核心，可以认为它是浏览器环境下的  <code>require</code>。在函数体最后使用  <code>__webpack_require__</code>加载了工程的入口模块，<strong>在浏览器中执行时即会从入口开始去逐步执行后面的模块</strong>。让我们看一下  <code>__webpack_require__</code>  的具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Check if module is in cache</span></span><br><span class="line">  <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Create a new module (and put it into the cache)</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: <span class="literal">false</span>,</span><br><span class="line">    exports: &#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// Execute the module function</span></span><br><span class="line">  modules[moduleId].call(</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// Flag the module as loaded</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">// Return the exports of the module</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码可以看出  <code>__webpack_require__</code>  主要做了几个事情：</p>
<ol>
<li>检查该模块是否已经加载过，如果是则直接返回已加载过的</li>
<li>添加 moduleId 等属性，并把该模块放进 installedModules</li>
<li>将模块 this 指到它的 module.exports，并执行已经包装好的模块逻辑</li>
<li>返回 modules.exports<br>在 Webpack 包装模块代码的时候，会<strong>把&nbsp;</strong><code><strong><strong>webpack_require</strong></strong></code><strong>&nbsp;作为参数传进去</strong>。在实际的模块代码中，导入其它模块的语句都会被替换为这种浏览器可以执行的形式，<strong>通过这种方式使模块间有了互相调用的能力。</strong><br>纵观整个 bundle.js，Webpack 主要在打包中处理了下面这些问题：</li>
<li>从入口文件开始分析整个应用的依赖树</li>
<li>将每个依赖模块包装起来，并放到一个数组中等待调用</li>
<li>实现模块加载的方法，并提供到模块执行的环境中，使得模块间可以互相调用</li>
<li>将执行入口文件的逻辑放在一个立即执行函数表达式中当浏览器执行这个 bundle.js 时，<strong>首先会执行入口文件的逻辑，接着会利用 Webpack 提供好的模块以及模块的加载方法来根据依赖关系一步步执行整个应用。</strong>以上就是一个简单的 Webpack 处理打包的过程。</li>
</ol>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Javascript/" rel="tag"># Javascript</a>
          
            <a href="/tags/Webpack/" rel="tag"># Webpack</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/08/css-style-conflict/" rel="next" title="CSS怎么解决样式冲突">
                <i class="fa fa-chevron-left"></i> CSS怎么解决样式冲突
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/08/Use webpack/" rel="prev" title="为什么要使用Webpack">
                为什么要使用Webpack <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Anderson</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#曾经的-Web-开发的做法和缺陷："><span class="nav-number">1.</span> <span class="nav-text">曾经的 Web 开发的做法和缺陷：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后来的解决办法"><span class="nav-number">2.</span> <span class="nav-text">后来的解决办法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#走向正轨的第一步——模块化"><span class="nav-number">3.</span> <span class="nav-text">走向正轨的第一步——模块化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用："><span class="nav-number">3.1.</span> <span class="nav-text">作用：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-模块发展简史"><span class="nav-number">4.</span> <span class="nav-text">JavaScript 模块发展简史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最原始的方式-script-标签"><span class="nav-number">4.0.1.</span> <span class="nav-text">最原始的方式: script 标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#立即执行函数表达式-IIFE"><span class="nav-number">4.0.2.</span> <span class="nav-text">立即执行函数表达式(IIFE)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AMD"><span class="nav-number">4.0.3.</span> <span class="nav-text">AMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Browserify-与-CommonJS"><span class="nav-number">4.0.4.</span> <span class="nav-text">Browserify 与 CommonJS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ES6-Module"><span class="nav-number">4.0.5.</span> <span class="nav-text">ES6 Module</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态加载模块"><span class="nav-number">4.0.6.</span> <span class="nav-text">动态加载模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块打包原理简述–Webpack"><span class="nav-number">4.0.7.</span> <span class="nav-text">模块打包原理简述–Webpack</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Anderson</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.2.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.2.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
